#!/usr/bin/env python

# TODO Right now joining is done all over the place... What if every element
# can indicate how it wants to be joined with other elements?

"""
An object oriented replacement for html2vimdoc.py which supports nested block
level elements and other nasty complexities (in converting HTML to Vim's plain
text help file format).

1. Parse input HTML using ``BeautifulSoup``
2. Build an AST of everything we know how to convert, drop the rest
3. Recurse into the AST to perform the conversion to Vim help file?

"""

# Standard library modules.
import logging
import re
import textwrap

# External dependency, install with:
#   sudo apt-get install python-beautifulsoup
#   pip install beautifulsoup
from BeautifulSoup import BeautifulSoup, NavigableString

# External dependency, install with:
#  pip install coloredlogs
import coloredlogs

# External dependency, bundled because it's not on PyPi.
import libs.soupselect as soupselect

# Sensible defaults.
TEXT_WIDTH = 79
SHIFT_WIDTH = 2

# Initialize the logging subsystem.
logger = logging.getLogger()
logger.setLevel(logging.DEBUG)
logger.addHandler(coloredlogs.ColoredStreamHandler())

def main():
    filename = 'demo/lpeg-0.10.html'
    filename = 'demo/apr-0.17.html'
    with open(filename) as handle:
        html = handle.read()
        html = re.sub(r'test coverage: \S+', '', html)
        output = Converter().convert(html, selectors_to_ignore=['h3 a[class=anchor]'])
        print output.encode('utf-8')

class Converter(object):

    # XXX This class is just here for decoration, it's not useful :-x

    def convert(self, html, selector='#content', selectors_to_ignore=[]):
        """
        Convert HTML source code to the Vim help file format.
        """
        html = self.decode_hexadecimal_entities(html)
        tree = BeautifulSoup(html, convertEntities=BeautifulSoup.ALL_ENTITIES)
        root = self.find_root_node(tree, selector)
        self.ignore_given_selectors(tree, selectors_to_ignore)
        extract = self.simplify_tree(root)
        # TODO Intermediate pass over AST to shift headings so that top level headings have level 1.
        vimdoc = extract.render(level=0)
        return vimdoc + "\n\nvim: ft=help"

    def decode_hexadecimal_entities(self, html):
        """
        Based on my testing BeautifulSoup doesn't support hexadecimal HTML
        entities, so we have to decode them ourselves :-(
        """
        # If we happen to decode an entity into one of these characters, we
        # should never insert it literally into the HTML because we'll screw
        # up the syntax.
        unsafe_to_decode = {
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&apos;',
                '&': '&amp;',
        }
        def decode_entity(match):
            character = chr(int(match.group(1), 16))
            return unsafe_to_decode.get(character, character)
        return re.sub(r'&#x([0-9A-Fa-f]+);', decode_entity, html)

    def find_root_node(self, tree, selector):
        """
        Given a document tree generated by BeautifulSoup, find the most
        specific document node that doesn't "lose any information" (i.e.
        everything that we want to be included in the Vim help file) while
        ignoring as much fluff as possible (e.g. headers, footers and
        navigation menus).
        """
        # Try to find the root node using a CSS selector provided by the caller.
        matches = soupselect.select(tree, selector)
        if matches:
            return matches[0]
        # Otherwise we'll fall back to the <body> element.
        try:
            return tree.html.body
        except:
            # Don't break when html.body doesn't exist.
            return tree

    def ignore_given_selectors(self, tree, selectors_to_ignore):
        """
        Remove all HTML elements matching any of the CSS selectors provided by
        the caller from the parse tree generated by BeautifulSoup.
        """
        for selector in selectors_to_ignore:
            for element in soupselect.select(tree, selector):
                element.extract()

    def simplify_tree(self, tree):
        """
        Simplify the tree generated by BeautifulSoup into something we can
        easily generate a Vim help file from.
        """
        return simplify_node(tree)

def simplify_node(html_node):
    name = getattr(html_node, 'name', None)
    logger.debug("Trying to map element with name %s", name)
    if name in name_to_type_mapping:
        mapped_type = name_to_type_mapping[name]
        logger.debug("Found a mapped type: %s", mapped_type)
        return mapped_type.parse(html_node)
    elif isinstance(html_node, NavigableString):
        logger.debug("Not an element but a string!")
        return Text(html_node.string)
    else:
        logger.debug("Not a supported element, improvising ..")
        return simplify_children(html_node)

def simplify_children(node):
    contents = []
    for child in getattr(node, 'contents', []):
        simplified_child = simplify_node(child)
        if simplified_child:
            contents.append(simplified_child)
    if is_block_level(contents):
        logger.debug("Sequence contains some block level elements")
        return BlockLevelSequence(contents=contents)
    else:
        logger.debug("Sequence contains only inline elements")
        return InlineSequence(contents=contents)

# Decorators.

name_to_type_mapping = {}

def html_element(*element_names):
    """
    Decorator to associate AST nodes and HTML nodes at the point where the AST
    node is defined.
    """
    def wrap(c):
        for name in element_names:
            name_to_type_mapping[name] = c
        return c
    return wrap

# Abstract parse tree nodes.

class Node(object):

    def __init__(self, **kw):
        """
        Short term hack for prototyping :-).
        """
        self.__dict__ = kw

    def __repr__(self):
        """
        Dumb but useful representation of parse tree for debugging purposes.
        """
        children = ",\n".join(repr(c) for c in self.contents)
        return "%s(%s)" % (self.__class__.__name__, children)

    @classmethod
    def parse(cls, html_node):
        """
        Default parse behavior: Just simplify any child nodes.
        """
        return cls(contents=simplify_children(html_node))

class BlockLevelNode(Node):
    pass

class InlineNode(Node):
    pass

# Concrete parse tree nodes.

class BlockLevelSequence(BlockLevelNode):

    def __iter__(self):
        """
        Quick hack to make it easier to walk the tree.
        """
        return iter(self.contents)

    def render(self, level):
        return join_blocks(self.contents, level=level)

@html_element('h1', 'h2', 'h3', 'h4', 'h5', 'h6')
class Heading(BlockLevelNode):

    @staticmethod
    def parse(html_node):
        return Heading(level=int(html_node.name[1]),
                       contents=simplify_children(html_node))

    def render(self, level):
        # Join the inline child nodes together into a single string.
        text = join_inline(self.contents, level=level)
        # Wrap the heading's text. The two character difference is " ~", the
        # suffix used to mark Vim help file headings.
        lines = [line + " ~" for line in textwrap.wrap(text, width=TEXT_WIDTH - 2)]
        # Add a line with the marker symbol for headings, repeated on the full
        # line, at the top of the heading.
        lines.insert(0, ('=' if level == 1 else '-') * 79)
        return "\n".join(lines)

@html_element('p')
class Paragraph(BlockLevelNode):

    def render(self, level):
        indent = " " * (level * SHIFT_WIDTH)
        return "\n".join(textwrap.wrap(join_inline(self.contents, level=level),
                                       width=TEXT_WIDTH,
                                       initial_indent=indent,
                                       subsequent_indent=indent))

@html_element('pre')
class PreformattedText(BlockLevelNode):

    @staticmethod
    def parse(html_node):
        text = ''.join(html_node.findAll(text=True))
        return PreformattedText(contents=[text])

    def render(self, level):
        indent = " " * (level + 4)
        # Remove common indentation from the original text.
        text = textwrap.dedent(self.contents[0])
        # Remove leading/trailing empty lines.
        lines = text.splitlines()
        while lines and not lines[0].strip():
            lines.pop(0)
        while lines and not lines[-1].strip():
            lines.pop(-1)
        # Indent the original text.
        output = []
        for line in lines:
            output.append(indent + line)
        # Add a Vim help file marker indicating the preformatted text.
        output.insert(0, ">")
        return "\n".join(output)

@html_element('ul', 'ol')
class List(BlockLevelNode):

    @staticmethod
    def parse(html_node):
        return List(ordered=(html_node.name=='ol'),
                    contents=simplify_children(html_node))

    def render(self, level):
        items = []
        delimiter = '\n'
        for i, node in enumerate(self.contents, start=1):
            if isinstance(node, ListItem):
                bullet = '%i. ' % i if self.ordered else '- '
                text = node.render(level=level + (len(bullet) / SHIFT_WIDTH))
                items.append(bullet + text.lstrip())
                if '\n' in text:
                    delimiter = '\n\n'
        return delimiter.join(items)

@html_element('li')
class ListItem(BlockLevelNode):

    def render(self, level):
        # TODO ListItem is kind of a special case? This should wrap long lines
        # when self.contents is all inline, otherwise it shouldn't touch it...
        # Shift everything by 
        if is_block_level(self.contents):
            return join_blocks(self.contents, level=level)
        else:
            text = join_inline(self.contents, level=level)
            # TODO Text wrap.
            #return "\n".join(textwrap.wrap(text, ))
        indent = " " * (level * SHIFT_WIDTH)
        return "\n".join(textwrap.wrap(join_inline(self.contents, level=level),
                                       width=TEXT_WIDTH,
                                       initial_indent=indent,
                                       subsequent_indent=indent))


@html_element('table')
class Table(BlockLevelNode):

    def render(self, level):
        return ''

class InlineSequence(InlineNode):

    def __iter__(self):
        return iter(self.contents)

    def render(self, level):
        return join_inline(self.contents, level=level)

class Text(InlineNode):

    def __init__(self, value):
        self.contents = [value]

    def render(self, level):
        return self.contents[0]

def is_block_level(contents):
    return any(isinstance(n, BlockLevelNode) for n in contents)

def join_smart(nodes, level):
    """
    Join a sequence of block level and/or inline nodes into a single string.
    """
    if is_block_level(nodes):
        return join_blocks(nodes, level)
    else:
        return join_inline(nodes, level)

def join_blocks(nodes, level):
    """
    Join a sequence of block level nodes into a single string.
    """
    output = ''
    for node in nodes:
        text = node.render(level=level)
        if text and not text.isspace():
            if not output:
                output = text
            elif isinstance(node, PreformattedText):
                output += '\n' + text
            else:
                output += '\n\n' + text
    return output

def join_inline(nodes, level):
    """
    Join a sequence of inline nodes into a single string.
    """
    return compact("".join(n.render(level=level) for n in nodes))

def compact(text):
    """
    Compact whitespace in a string (also trims whitespace from the sides).
    """
    return " ".join(text.split())

if __name__ == '__main__':
    main()

# vim: ft=python ts=4 sw=4 et
